name: Release ClickHouse

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'ClickHouse version'
        required: true
        type: choice
        options:
          - 25.12.3.21
        default: 25.12.3.21
      platforms:
        description: 'Platforms to build'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'linux-x64'
          - 'linux-arm64'
          - 'darwin-x64'
          - 'darwin-arm64'
          - 'win32-x64'

# Prevent concurrent runs that could conflict when updating releases.json
concurrency:
  group: release-clickhouse
  cancel-in-progress: false

jobs:
  # Validate version against databases.json
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate version against databases.json
        run: |
          VERSION="${{ github.event.inputs.version }}"
          DB="clickhouse"

          echo "Validating ClickHouse version: $VERSION"

          # Check if version exists and is enabled in databases.json
          ENABLED=$(jq -r ".databases.$DB.versions[\"$VERSION\"] // false" databases.json)
          if [ "$ENABLED" != "true" ]; then
            echo "::error::Version '$VERSION' is not enabled in databases.json"
            echo ""
            echo "Available versions:"
            jq -r ".databases.$DB.versions | to_entries | map(select(.value == true)) | .[].key" databases.json
            exit 1
          fi

          echo "✓ Version $VERSION is enabled in databases.json"

      - name: Validate sources.json exists
        run: |
          DB="clickhouse"
          if [ ! -f "builds/$DB/sources.json" ]; then
            echo "::error::Missing builds/$DB/sources.json"
            exit 1
          fi
          echo "✓ builds/$DB/sources.json exists"

      - name: Validate version in sources.json
        run: |
          VERSION="${{ github.event.inputs.version }}"
          DB="clickhouse"

          HAS_VERSION=$(jq -r ".versions[\"$VERSION\"] // empty" "builds/$DB/sources.json")
          if [ -z "$HAS_VERSION" ]; then
            echo "::error::Version '$VERSION' not found in builds/$DB/sources.json"
            echo ""
            echo "Available versions in sources.json:"
            jq -r ".versions | keys[]" "builds/$DB/sources.json"
            exit 1
          fi

          echo "✓ Version $VERSION found in sources.json"

  # Determine which platforms to build based on input
  prepare:
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      download-matrix: ${{ steps.set-matrix.outputs.download-matrix }}
      build-matrix: ${{ steps.set-matrix.outputs.build-matrix }}
      has-downloads: ${{ steps.set-matrix.outputs.has-downloads }}
      has-builds: ${{ steps.set-matrix.outputs.has-builds }}
    steps:
      - name: Set build matrix
        id: set-matrix
        run: |
          PLATFORMS="${{ github.event.inputs.platforms }}"

          # Download platforms (Linux + macOS - have official binaries)
          DOWNLOAD_PLATFORMS='["linux-x64", "linux-arm64", "darwin-x64", "darwin-arm64"]'

          # Build platforms (Windows - requires source build)
          BUILD_PLATFORMS='["win32-x64"]'

          if [ "$PLATFORMS" = "all" ]; then
            # All platforms
            DOWNLOAD_MATRIX='[
              {"platform": "linux-x64", "runner": "ubuntu-latest"},
              {"platform": "linux-arm64", "runner": "ubuntu-latest"},
              {"platform": "darwin-x64", "runner": "macos-15-intel"},
              {"platform": "darwin-arm64", "runner": "macos-14"}
            ]'
            BUILD_MATRIX='[
              {"platform": "win32-x64", "runner": "windows-latest"}
            ]'
            HAS_DOWNLOADS="true"
            HAS_BUILDS="true"
          elif echo "$DOWNLOAD_PLATFORMS" | jq -e "index(\"$PLATFORMS\")" > /dev/null; then
            # Single download platform
            case "$PLATFORMS" in
              linux-x64|linux-arm64)
                DOWNLOAD_MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"ubuntu-latest\"}]"
                ;;
              darwin-x64)
                DOWNLOAD_MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"macos-15-intel\"}]"
                ;;
              darwin-arm64)
                DOWNLOAD_MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"macos-14\"}]"
                ;;
            esac
            BUILD_MATRIX='[]'
            HAS_DOWNLOADS="true"
            HAS_BUILDS="false"
          elif echo "$BUILD_PLATFORMS" | jq -e "index(\"$PLATFORMS\")" > /dev/null; then
            # Single build platform
            DOWNLOAD_MATRIX='[]'
            BUILD_MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"windows-latest\"}]"
            HAS_DOWNLOADS="false"
            HAS_BUILDS="true"
          else
            echo "::error::Unknown platform: $PLATFORMS"
            exit 1
          fi

          # Compact the JSON for output
          DOWNLOAD_MATRIX=$(echo "$DOWNLOAD_MATRIX" | jq -c .)
          BUILD_MATRIX=$(echo "$BUILD_MATRIX" | jq -c .)

          echo "download-matrix=$DOWNLOAD_MATRIX" >> $GITHUB_OUTPUT
          echo "build-matrix=$BUILD_MATRIX" >> $GITHUB_OUTPUT
          echo "has-downloads=$HAS_DOWNLOADS" >> $GITHUB_OUTPUT
          echo "has-builds=$HAS_BUILDS" >> $GITHUB_OUTPUT

          echo "Download platforms: $DOWNLOAD_MATRIX"
          echo "Build platforms: $BUILD_MATRIX"

  # Download and repackage official binaries (Linux + macOS)
  build-download:
    needs: prepare
    if: needs.prepare.outputs.has-downloads == 'true'
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.download-matrix) }}
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Download and repackage binary
        id: download
        timeout-minutes: 30
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PLATFORM="${{ matrix.platform }}"

          echo "Downloading ClickHouse $VERSION for $PLATFORM"

          pnpm download:clickhouse -- \
            --version "$VERSION" \
            --platform "$PLATFORM" \
            --output ./dist

          # Check if artifact was created
          shopt -s nullglob
          FILES=(./dist/clickhouse-*.tar.gz)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "::error::No artifact created for $PLATFORM"
            exit 1
          fi
          ls -la ./dist/

      - name: Generate checksum
        shell: bash
        run: |
          cd dist
          shopt -s nullglob
          for f in *.tar.gz *.zip; do
            if [ -f "$f" ]; then
              if command -v sha256sum &> /dev/null; then
                sha256sum "$f" >> checksums.txt
              else
                # macOS uses shasum
                shasum -a 256 "$f" >> checksums.txt
              fi
            fi
          done
          cat checksums.txt

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: clickhouse-${{ github.event.inputs.version }}-${{ matrix.platform }}
          path: |
            dist/*.tar.gz
            dist/checksums.txt
          retention-days: 1

  # Build from source (Windows - EXPERIMENTAL)
  build-source:
    needs: prepare
    if: needs.prepare.outputs.has-builds == 'true'
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.build-matrix) }}
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # Setup MSYS2 with CLANG64 environment for Windows builds
      # CLANG64 provides native Windows binaries using Clang/LLVM
      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: CLANG64
          update: true
          install: >-
            mingw-w64-clang-x86_64-clang
            mingw-w64-clang-x86_64-lld
            mingw-w64-clang-x86_64-cmake
            mingw-w64-clang-x86_64-ninja
            mingw-w64-clang-x86_64-openssl
            mingw-w64-clang-x86_64-zlib
            mingw-w64-clang-x86_64-zstd
            mingw-w64-clang-x86_64-lz4
            mingw-w64-clang-x86_64-xz
            mingw-w64-clang-x86_64-libxml2
            mingw-w64-clang-x86_64-python
            mingw-w64-clang-x86_64-nasm
            git
            zip

      # Cache ClickHouse source to speed up iteration (~3 min savings)
      - name: Cache ClickHouse source
        id: cache-clickhouse
        uses: actions/cache@v4
        with:
          path: ClickHouse
          key: clickhouse-source-${{ github.event.inputs.version }}

      # EXPERIMENTAL: Build ClickHouse for Windows using MSYS2 CLANG64
      # This targets native Windows (not POSIX emulation like Cygwin)
      - name: Build ClickHouse (MSYS2 CLANG64 - EXPERIMENTAL)
        id: build-windows
        timeout-minutes: 360
        shell: msys2 {0}
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PLATFORM="win32-x64"

          echo "=========================================="
          echo "EXPERIMENTAL: Building ClickHouse $VERSION for Windows (MSYS2 CLANG64)"
          echo "This build is experimental and may fail!"
          echo "=========================================="

          # Check build environment
          echo "Environment:"
          echo "MSYSTEM: $MSYSTEM"
          echo "PATH: $PATH"

          # Check Clang version
          echo ""
          echo "Clang version:"
          clang --version

          echo ""
          echo "CMake version:"
          cmake --version

          # Clone ClickHouse source (shallow for speed) - skip if cached
          cd "$GITHUB_WORKSPACE"
          if [ -d "ClickHouse" ] && [ -f "ClickHouse/CMakeLists.txt" ]; then
            echo ""
            echo "Using cached ClickHouse source..."
            # Clean any previous build artifacts
            rm -rf ClickHouse/build
          else
            echo ""
            echo "Cloning ClickHouse source..."
            rm -rf ClickHouse
            git clone --depth 1 --branch "v${VERSION}-stable" \
              --recurse-submodules --shallow-submodules \
              https://github.com/ClickHouse/ClickHouse.git
          fi

          cd ClickHouse

          # Patch cmake/arch.cmake to support Windows (AMD64)
          # ClickHouse's pattern "amd64|x86_64" is lowercase only, but Windows reports "AMD64" uppercase
          # This is a bug/oversight in ClickHouse - ARM64 patterns include uppercase variants but x86 doesn't
          echo ""
          echo "Patching cmake/arch.cmake for Windows AMD64 support..."
          sed -i 's/"amd64|x86_64"/"amd64|AMD64|x86_64"/g' cmake/arch.cmake
          echo "Patched arch.cmake pattern:"
          grep -n "amd64" cmake/arch.cmake || true

          # Patch cmake/target.cmake to support Windows
          # ClickHouse only supports Linux/Darwin/FreeBSD/Android/SunOS
          #
          # KEY INSIGHT: We need to separate CMake variables from preprocessor defines.
          #   - CMake variable OS_LINUX triggers cmake/linux/default_libs.cmake which
          #     sets Linux linker flags (-lrt, -ldl, -lpthread) that don't exist on Windows.
          #   - Preprocessor define OS_LINUX is needed for C++ code compilation since
          #     ClickHouse uses #ifdef OS_LINUX guards everywhere.
          #
          # SOLUTION: Only set preprocessor defines, NOT CMake variables for OS_LINUX.
          # This lets C++ code compile while avoiding Linux-specific CMake configuration.
          echo ""
          echo "Patching cmake/target.cmake for Windows support..."
          WINDOWS_PATCH='elseif (CMAKE_SYSTEM_NAME MATCHES "Windows")\n    # Only set OS_WINDOWS as CMake var - NOT OS_LINUX (avoids Linux cmake includes)\n    set (OS_WINDOWS 1)\n    # But define OS_LINUX for preprocessor so C++ code compiles\n    add_definitions(-D OS_LINUX)\n    add_definitions(-D OS_WINDOWS)\nelse ()'
          sed -i "s/^else ()$/${WINDOWS_PATCH}/" cmake/target.cmake
          echo "Patched target.cmake:"
          grep -n -A2 "Windows" cmake/target.cmake || true

          # Patch PreLoad.cmake to allow custom CMAKE_CXX_FLAGS
          # ClickHouse normally rejects any custom flags, but we need -include for our compat header
          echo ""
          echo "Patching PreLoad.cmake to allow custom flags..."
          sed -i 's/message(FATAL_ERROR/message(WARNING/' PreLoad.cmake
          echo "Patched PreLoad.cmake (changed FATAL_ERROR to WARNING)"

          # Patch CMakeLists.txt to add find_package(Threads) early
          # ClickHouse doesn't call this, but abseil-cpp and xz need Threads::Threads target
          echo ""
          echo "Patching CMakeLists.txt to add Threads package..."
          sed -i '/^project(/a\\n# Added for Windows build - create Threads::Threads target\nset(THREADS_PREFER_PTHREAD_FLAG ON)\nfind_package(Threads REQUIRED)\n' CMakeLists.txt
          echo "Patched CMakeLists.txt (added find_package(Threads))"

          # Patch LLVM TargetParser.h to avoid NO_ERROR enum conflict with Windows macro
          # NO_ERROR is defined as 0 in Windows winerror.h, but LLVM uses it as an enum value
          # We rename it to FEATURE_NO_ERROR to avoid the conflict
          echo ""
          echo "Patching LLVM TargetParser.h to avoid NO_ERROR macro conflict..."
          LLVM_TARGET_PARSER="contrib/llvm-project/llvm/include/llvm/TargetParser/TargetParser.h"
          if [ -f "$LLVM_TARGET_PARSER" ]; then
            sed -i 's/NO_ERROR/FEATURE_NO_ERROR/g' "$LLVM_TARGET_PARSER"
            # Also patch the .cpp file that uses the enum
            sed -i 's/NO_ERROR/FEATURE_NO_ERROR/g' contrib/llvm-project/llvm/lib/TargetParser/TargetParser.cpp
            echo "Patched TargetParser files (NO_ERROR -> FEATURE_NO_ERROR)"
          fi

          # Patch openssl-cmake to force a Windows target so it doesn't select linux_x86_64
          # This prevents Linux asm config from being chosen on Windows builds.
          echo ""
          echo "Patching openssl-cmake to force Windows target..."
          OPENSSL_CMAKE="contrib/openssl-cmake/CMakeLists.txt"
          if [ -f "$OPENSSL_CMAKE" ]; then
            # Insert once, right after project() to keep it near the top.
            if ! rg -q "OPENSSL_TARGET_FORCE_WINDOWS" "$OPENSSL_CMAKE"; then
              sed -i '/project(/a\\n# OPENSSL_TARGET_FORCE_WINDOWS\nif (WIN32)\n  if (NOT OPENSSL_TARGET)\n    set(OPENSSL_TARGET "mingw64")\n  endif()\nendif()\n' "$OPENSSL_CMAKE"
            fi
            echo "Patched openssl-cmake (forced OPENSSL_TARGET=mingw64 on WIN32)"
            echo "openssl-cmake header (first 80 lines):"
            sed -n '1,80p' "$OPENSSL_CMAKE" || true
            echo "openssl-cmake target/platform hints:"
            rg -n "OPENSSL_TARGET|OPENSSL_PLATFORM|OPENSSL_CONFIG|mingw|win64|linux_x86_64|CMAKE_SYSTEM_NAME|CMAKE_SYSTEM_PROCESSOR" "$OPENSSL_CMAKE" || true
          else
            echo "WARNING: openssl-cmake CMakeLists.txt not found"
          fi

          # Patch OpenSSL bn_div.c to disable broken inline assembly on Windows
          # The issue is that the inline asm uses "divq %4" which generates "divq %r11d"
          # (64-bit instruction with 32-bit register) - this is broken on MSYS2/Windows.
          # The bn_div_words macro is controlled by SIXTY_FOUR_BIT / SIXTY_FOUR_BIT_LONG.
          # We insert undefs RIGHT BEFORE the macro definition (after includes).
          # NOTE: Removed ^ anchor - the line may have leading whitespace.
          echo ""
          echo "Patching OpenSSL bn_div.c to disable broken inline assembly..."
          OPENSSL_BN_DIV="contrib/openssl/crypto/bn/bn_div.c"
          if [ -f "$OPENSSL_BN_DIV" ]; then
            # Insert undefs right before the bn_div_words macro definition
            # Pattern without ^ anchor to match regardless of leading whitespace
            sed -i '/#if defined(SIXTY_FOUR_BIT_LONG)/i\/* Disable broken inline asm on Windows - must be after includes */\n#undef SIXTY_FOUR_BIT_LONG\n#undef SIXTY_FOUR_BIT\n' "$OPENSSL_BN_DIV"
            echo "Patched bn_div.c (disabled inline assembly before macro def)"
            # Verify the patch was applied by checking if our comment exists
            if grep -q "Disable broken inline asm" "$OPENSSL_BN_DIV"; then
              echo "Verified: patch successfully applied"
            else
              echo "WARNING: patch may not have been applied!"
            fi
          fi

          # Create Windows compatibility header with POSIX stubs
          # IMPORTANT: Do NOT include <windows.h> here - it causes massive macro pollution
          # (IMAGE_FILE_MACHINE_*, NO_ERROR, OPTIONAL, etc.) that breaks LLVM enums.
          # Instead, provide minimal stubs without Windows SDK dependencies.
          echo ""
          echo "Creating Windows compatibility header (minimal, no windows.h)..."
          printf '%s\n' \
            '#pragma once' \
            '#ifdef _WIN32' \
            '' \
            '// Minimal POSIX compatibility stubs for Windows' \
            '// We intentionally do NOT include <windows.h> to avoid macro pollution' \
            '' \
            '#include <stddef.h>  // for size_t' \
            '' \
            '// sysconf constants' \
            '#ifndef _SC_PAGESIZE' \
            '#define _SC_PAGESIZE 1' \
            '#endif' \
            '#ifndef _SC_NPROCESSORS_ONLN' \
            '#define _SC_NPROCESSORS_ONLN 2' \
            '#endif' \
            '' \
            '// Simple stubs - use reasonable defaults instead of calling Windows API' \
            'static inline int getpagesize(void) { return 4096; }' \
            'static inline long sysconf(int name) {' \
            '    switch(name) {' \
            '        case _SC_PAGESIZE: return 4096;' \
            '        case _SC_NPROCESSORS_ONLN: return 4;' \
            '        default: return -1;' \
            '    }' \
            '}' \
            '' \
            '// Signal stack stubs (not used on Windows)' \
            '#ifndef SIGSTKSZ' \
            '#define SIGSTKSZ 8192' \
            '#endif' \
            'typedef struct { void *ss_sp; int ss_flags; size_t ss_size; } stack_t;' \
            'static inline int sigaltstack(const stack_t *ss, stack_t *old_ss) {' \
            '    (void)ss; (void)old_ss; return 0;' \
            '}' \
            '' \
            '#endif // _WIN32' \
            > compat_windows.h
          echo "Created compat_windows.h (minimal, no windows.h)"

          # Configure with CMake
          echo ""
          echo "Configuring with CMake..."
          mkdir -p build && cd build
          COMPAT_HEADER="$GITHUB_WORKSPACE/ClickHouse/compat_windows.h"

          # Use MSYS2's clang from CLANG64 environment
          # Disable many features that require Linux-specific APIs
          # Include compat_windows.h for POSIX stubs
          cmake .. \
            -DCMAKE_C_COMPILER=clang \
            -DCMAKE_CXX_COMPILER=clang++ \
            -DCMAKE_CXX_FLAGS="-include ${COMPAT_HEADER}" \
            -DCMAKE_LINKER=ld.lld \
            -DLINKER_NAME=ld.lld \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_SYSTEM_PROCESSOR=x86_64 \
            -DCOMPILER_CACHE=disabled \
            -DENABLE_TESTS=OFF \
            -DENABLE_UTILS=OFF \
            -DENABLE_EMBEDDED_COMPILER=OFF \
            -DENABLE_RUST=OFF \
            -DUSE_STATIC_LIBRARIES=ON \
            -DENABLE_NURAFT=OFF \
            -DENABLE_JEMALLOC=OFF \
            -DENABLE_CLICKHOUSE_ODBC_BRIDGE=OFF \
            -DENABLE_CLICKHOUSE_LIBRARY_BRIDGE=OFF \
            -DENABLE_CLICKHOUSE_KEEPER=OFF \
            -DENABLE_CLICKHOUSE_KEEPER_CONVERTER=OFF \
            -DENABLE_CLICKHOUSE_SU=OFF \
            -DENABLE_CLICKHOUSE_DISKS=OFF \
            -DENABLE_LDAP=OFF \
            -DENABLE_ISA_L=OFF \
            -DENABLE_HDFS=OFF \
            -DENABLE_KAFKA=OFF \
            -DENABLE_NATS=OFF \
            -DENABLE_AMQPCPP=OFF \
            -DENABLE_CASSANDRA=OFF \
            -DENABLE_S3=OFF \
            -DENABLE_AZURE_BLOB_STORAGE=OFF \
            -DENABLE_GRPC=OFF \
            -DENABLE_MYSQL=OFF \
            -DENABLE_MONGODB=OFF \
            -DENABLE_POSTGRESQL=OFF \
            -DENABLE_LIBURING=OFF \
            -DENABLE_PARQUET=OFF \
            -DENABLE_SSH=OFF \
            -GNinja || {
              echo "::warning::CMake configuration failed. This is expected for experimental Windows builds."
              echo "::warning::ClickHouse does not officially support Windows."
              exit 1
            }

          # Build clickhouse binary (includes all subcommands: server, client, local, etc.)
          # Note: clickhouse-local is an alias, not a separate target - we must build 'clickhouse'
          echo ""
          echo "Building ClickHouse..."
          ninja clickhouse || {
            echo "::warning::Build failed. This is expected for experimental Windows builds."
            echo "::warning::ClickHouse does not officially support Windows."
            exit 1
          }

          # If we get here, the build succeeded! Package it.
          echo ""
          echo "Build succeeded! Packaging..."

          cd "$GITHUB_WORKSPACE"
          mkdir -p install/clickhouse/bin

          # Copy clickhouse-local binary (might be .exe on Windows)
          if [ -f ClickHouse/build/programs/clickhouse-local.exe ]; then
            cp ClickHouse/build/programs/clickhouse-local.exe install/clickhouse/bin/clickhouse-local.exe
          elif [ -f ClickHouse/build/programs/clickhouse-local ]; then
            cp ClickHouse/build/programs/clickhouse-local install/clickhouse/bin/
          else
            # Fallback: clickhouse-local might be part of main clickhouse binary
            if [ -f ClickHouse/build/programs/clickhouse.exe ]; then
              cp ClickHouse/build/programs/clickhouse.exe install/clickhouse/bin/
            else
              cp ClickHouse/build/programs/clickhouse install/clickhouse/bin/
            fi
          fi

          # Add metadata
          cat > install/clickhouse/.hostdb-metadata.json << EOF
          {
            "name": "clickhouse",
            "version": "${VERSION}",
            "platform": "${PLATFORM}",
            "source": "source-build",
            "sourceUrl": "https://github.com/ClickHouse/ClickHouse",
            "rehosted_by": "hostdb",
            "rehosted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "note": "Experimental MSYS2 CLANG64 build - clickhouse-local only, limited functionality"
          }
          EOF

          # Create zip (Windows convention)
          mkdir -p dist
          cd install
          zip -r "../dist/clickhouse-${VERSION}-${PLATFORM}.zip" clickhouse

          echo ""
          echo "Build complete:"
          ls -la ../dist/

      - name: Generate checksum (Windows)
        if: steps.build-windows.outcome == 'success'
        shell: msys2 {0}
        run: |
          cd "$GITHUB_WORKSPACE/dist"
          for f in *.tar.gz *.zip; do
            if [ -f "$f" ]; then
              sha256sum "$f" >> checksums.txt
            fi
          done
          cat checksums.txt

      - name: Upload artifact
        if: steps.build-windows.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: clickhouse-${{ github.event.inputs.version }}-${{ matrix.platform }}
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/checksums.txt
          retention-days: 1

  # Collect all artifacts and create release
  release:
    needs: [build-download, build-source]
    if: always() && (needs.build-download.result == 'success' || needs.build-download.result == 'skipped') && (needs.build-source.result == 'success' || needs.build-source.result == 'skipped' || needs.build-source.result == 'failure')
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check if any artifacts exist
        id: check-artifacts
        run: |
          # We'll check after downloading
          echo "Checking for artifacts..."

      - name: Download download-job artifacts
        if: needs.build-download.result == 'success'
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: clickhouse-${{ github.event.inputs.version }}-*

      - name: Prepare release assets
        id: prepare
        run: |
          mkdir -p ./release-assets

          # Move all artifacts to release-assets, flattening the directory structure
          if [ -d ./artifacts ]; then
            find ./artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec mv {} ./release-assets/ \; 2>/dev/null || true

            # Combine all checksums
            find ./artifacts -name "checksums.txt" -exec cat {} \; > ./release-assets/checksums.txt 2>/dev/null || true
          fi

          echo "Release assets:"
          ls -la ./release-assets/ || echo "No release assets found"

          # Check if we have at least one artifact
          shopt -s nullglob
          FILES=(./release-assets/*.tar.gz ./release-assets/*.zip)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "::error::No artifacts were created for any platform"
            echo "has-artifacts=false" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "has-artifacts=true" >> $GITHUB_OUTPUT

          echo ""
          echo "Checksums:"
          cat ./release-assets/checksums.txt || echo "No checksums"

      - name: Create Release
        if: steps.prepare.outputs.has-artifacts == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: clickhouse-${{ github.event.inputs.version }}
          name: ClickHouse ${{ github.event.inputs.version }}
          body: |
            ## ClickHouse ${{ github.event.inputs.version }}

            ClickHouse binaries for hostdb.

            ClickHouse is a column-oriented database for real-time analytics and big data processing.

            ### Available Platforms
            | Platform | Source |
            |----------|--------|
            | `linux-x64` | Official binary (GitHub releases) |
            | `linux-arm64` | Official binary (GitHub releases) |
            | `darwin-x64` | Official binary (GitHub releases) |
            | `darwin-arm64` | Official binary (GitHub releases) |
            | `win32-x64` | **EXPERIMENTAL** Source build (Cygwin) |

            **Note:** Windows builds are experimental. ClickHouse does not officially support Windows. For production Windows use, consider WSL.

            ### Usage
            ```bash
            # Download URL pattern
            https://github.com/${{ github.repository }}/releases/download/clickhouse-${{ github.event.inputs.version }}/clickhouse-${{ github.event.inputs.version }}-<platform>.tar.gz
            ```

            ### Checksums
            See `checksums.txt` for SHA256 checksums.

            ### License
            ClickHouse is licensed under Apache-2.0.

            ### Sources
            - **Official**: [github.com/ClickHouse/ClickHouse](https://github.com/ClickHouse/ClickHouse)
          files: |
            release-assets/*.tar.gz
            release-assets/*.zip
            release-assets/checksums.txt
          fail_on_unmatched_files: false

  # Update the releases manifest
  update-manifest:
    needs: release
    if: needs.release.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Update releases.json
        run: |
          pnpm tsx scripts/update-releases.ts \
            --database clickhouse \
            --version "${{ github.event.inputs.version }}" \
            --tag "clickhouse-${{ github.event.inputs.version }}"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add releases.json
          git diff --staged --quiet && echo "No changes to commit" && exit 0

          git commit -m "chore: update releases.json for clickhouse-${{ github.event.inputs.version }}"

          # Retry push with rebase if remote has changed
          for i in 1 2 3; do
            if git push; then
              echo "Push succeeded"
              exit 0
            fi
            echo "Push failed, attempting rebase (attempt $i/3)..."
            git fetch origin main
            if ! git rebase origin/main; then
              echo "ERROR: Rebase failed due to conflicts. Manual intervention required."
              git rebase --abort
              exit 1
            fi
            sleep $((2**i))
          done
          echo "ERROR: Push failed after 3 attempts"
          exit 1
