name: Release PostgreSQL

on:
  workflow_dispatch:
    inputs:
      version:
        description: 'PostgreSQL version'
        required: true
        type: choice
        options:
          - 18.1.0
          - 17.7.0
          - 16.11.0
          - 15.15.0
        default: 18.1.0
      platforms:
        description: 'Platforms to build'
        required: true
        default: 'all'
        type: choice
        options:
          - 'all'
          - 'linux-x64'
          - 'linux-arm64'
          - 'darwin-x64'
          - 'darwin-arm64'
          - 'win32-x64'

# Prevent concurrent runs that could conflict when updating releases.json
concurrency:
  group: release-postgresql
  cancel-in-progress: false

jobs:
  # Validate version against databases.json
  validate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate version against databases.json
        run: |
          VERSION="${{ github.event.inputs.version }}"
          DB="postgresql"

          echo "Validating PostgreSQL version: $VERSION"

          # Check if version exists and is enabled in databases.json
          ENABLED=$(jq -r ".databases.$DB.versions[\"$VERSION\"] // false" databases.json)
          if [ "$ENABLED" != "true" ]; then
            echo "::error::Version '$VERSION' is not enabled in databases.json"
            echo ""
            echo "Available versions:"
            jq -r ".databases.$DB.versions | to_entries | map(select(.value == true)) | .[].key" databases.json
            exit 1
          fi

          echo "✓ Version $VERSION is enabled in databases.json"

      - name: Validate sources.json exists
        run: |
          DB="postgresql"
          if [ ! -f "builds/$DB/sources.json" ]; then
            echo "::error::Missing builds/$DB/sources.json"
            exit 1
          fi
          echo "✓ builds/$DB/sources.json exists"

      - name: Validate version in sources.json
        run: |
          VERSION="${{ github.event.inputs.version }}"
          DB="postgresql"

          HAS_VERSION=$(jq -r ".versions[\"$VERSION\"] // empty" "builds/$DB/sources.json")
          if [ -z "$HAS_VERSION" ]; then
            echo "::error::Version '$VERSION' not found in builds/$DB/sources.json"
            echo ""
            echo "Available versions in sources.json:"
            jq -r ".versions | keys[]" "builds/$DB/sources.json"
            exit 1
          fi

          echo "✓ Version $VERSION found in sources.json"

  # Determine which platforms to build based on input
  prepare:
    needs: validate
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      source_version: ${{ steps.parse-version.outputs.source_version }}
    steps:
      - name: Parse version for source download
        id: parse-version
        run: |
          # databases.json uses 3-part versions (18.1.0) but PostgreSQL source uses 2-part (18.1)
          VERSION="${{ github.event.inputs.version }}"
          # Remove trailing .0 if present (18.1.0 -> 18.1)
          SOURCE_VERSION=$(echo "$VERSION" | sed 's/\.0$//')
          echo "source_version=$SOURCE_VERSION" >> $GITHUB_OUTPUT
          echo "Source version: $SOURCE_VERSION (from $VERSION)"

      - name: Set build matrix
        id: set-matrix
        run: |
          PLATFORMS="${{ github.event.inputs.platforms }}"
          if [ "$PLATFORMS" = "all" ]; then
            # All 5 platforms with their appropriate runners
            MATRIX='[
              {"platform": "linux-x64", "runner": "ubuntu-latest", "build_type": "docker"},
              {"platform": "linux-arm64", "runner": "ubuntu-latest", "build_type": "docker"},
              {"platform": "darwin-x64", "runner": "macos-15-intel", "build_type": "native"},
              {"platform": "darwin-arm64", "runner": "macos-14", "build_type": "native"},
              {"platform": "win32-x64", "runner": "ubuntu-latest", "build_type": "download"}
            ]'
          else
            # Single platform - determine runner and build type
            case "$PLATFORMS" in
              linux-x64|linux-arm64)
                MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"ubuntu-latest\", \"build_type\": \"docker\"}]"
                ;;
              darwin-x64)
                MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"macos-15-intel\", \"build_type\": \"native\"}]"
                ;;
              darwin-arm64)
                MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"macos-14\", \"build_type\": \"native\"}]"
                ;;
              win32-x64)
                MATRIX="[{\"platform\": \"$PLATFORMS\", \"runner\": \"ubuntu-latest\", \"build_type\": \"download\"}]"
                ;;
              *)
                echo "::error::Unsupported platform: $PLATFORMS"
                echo "Valid platforms: linux-x64, linux-arm64, darwin-x64, darwin-arm64, win32-x64, all"
                exit 1
                ;;
            esac
          fi
          # Compact the JSON for output
          MATRIX=$(echo "$MATRIX" | jq -c .)
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT
          echo "Building platforms: $MATRIX"

  # Build each platform in parallel
  build:
    needs: prepare
    strategy:
      fail-fast: false
      matrix:
        include: ${{ fromJson(needs.prepare.outputs.matrix) }}
    runs-on: ${{ matrix.runner }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # Set up QEMU for cross-platform Docker builds (required for linux-arm64 on x64 runners)
      - name: Set up QEMU
        if: matrix.build_type == 'docker'
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: matrix.build_type == 'docker'
        uses: docker/setup-buildx-action@v3

      # Check if there's a download URL available in sources.json
      - name: Check for download URL
        if: matrix.build_type == 'docker'
        id: check-download
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PLATFORM="${{ matrix.platform }}"

          URL=$(jq -r ".versions[\"$VERSION\"][\"$PLATFORM\"].url // empty" builds/postgresql/sources.json)
          SOURCE_TYPE=$(jq -r ".versions[\"$VERSION\"][\"$PLATFORM\"].sourceType // empty" builds/postgresql/sources.json)

          if [ -n "$URL" ] && [ "$SOURCE_TYPE" != "build-required" ]; then
            echo "Found download URL for $PLATFORM: $URL"
            echo "has_url=true" >> $GITHUB_OUTPUT
            echo "url=$URL" >> $GITHUB_OUTPUT
            echo "source_type=$SOURCE_TYPE" >> $GITHUB_OUTPUT
          else
            echo "No download URL found, will build from source"
            echo "has_url=false" >> $GITHUB_OUTPUT
          fi

      # For Linux ARM64: download pre-built binary if URL available (Percona)
      - name: Download for Linux ARM64 (Percona)
        if: matrix.build_type == 'docker' && steps.check-download.outputs.has_url == 'true'
        id: download-linux-arm64
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PLATFORM="${{ matrix.platform }}"
          URL="${{ steps.check-download.outputs.url }}"
          SOURCE_TYPE="${{ steps.check-download.outputs.source_type }}"

          echo "Downloading PostgreSQL $VERSION for $PLATFORM from $SOURCE_TYPE"
          echo "URL: $URL"

          mkdir -p dist/downloads dist/temp

          # Download with retry
          for i in 1 2 3; do
            if curl -fsSL "$URL" -o "dist/downloads/postgresql-original.tar.gz"; then
              echo "Download succeeded"
              break
            fi
            echo "Download attempt $i failed, retrying..."
            sleep $((2**i))
          done

          if [ ! -f "dist/downloads/postgresql-original.tar.gz" ]; then
            echo "::error::Failed to download binary"
            exit 1
          fi

          # Extract and repackage
          cd dist/temp
          tar -xzf ../downloads/postgresql-original.tar.gz

          # Verify extracted layout - Percona extracts to multiple dirs including percona-postgresqlXX
          echo "Extracted contents:"
          ls -la

          # Find the PostgreSQL directory (Percona uses percona-postgresql{major_version} naming)
          # e.g., percona-postgresql18, percona-postgresql17, etc.
          EXTRACTED_DIR=$(ls -d percona-postgresql[0-9]* 2>/dev/null | head -1)

          if [ -z "$EXTRACTED_DIR" ]; then
            # Fallback to other patterns
            EXTRACTED_DIR=$(ls -d percona-postgresql-* 2>/dev/null | head -1)
          fi

          if [ -z "$EXTRACTED_DIR" ]; then
            EXTRACTED_DIR=$(ls -d postgresql-* 2>/dev/null | head -1)
          fi

          if [ -z "$EXTRACTED_DIR" ]; then
            echo "::error::Could not find PostgreSQL directory in tarball"
            echo "Contents:"
            find . -maxdepth 2 -type d
            exit 1
          fi

          echo "Found PostgreSQL directory: $EXTRACTED_DIR"
          mv "$EXTRACTED_DIR" postgresql

          # Clean up other Percona components we don't need
          rm -rf percona-etcd percona-haproxy percona-patroni percona-perl \
                 percona-pgbackrest percona-pgbadger percona-pgbouncer \
                 percona-pgpool-II percona-python3 percona-tcl 2>/dev/null || true

          # Add metadata
          cat > postgresql/.hostdb-metadata.json << EOF
          {
            "name": "postgresql",
            "version": "${VERSION}",
            "platform": "${PLATFORM}",
            "source": "${SOURCE_TYPE}",
            "sourceUrl": "${URL}",
            "rehosted_by": "hostdb",
            "rehosted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          # Verify key binaries exist
          if [ ! -f "postgresql/bin/postgres" ]; then
            echo "::error::postgres binary not found"
            find . -name "postgres" -type f 2>/dev/null || echo "No postgres binary found anywhere"
            exit 1
          fi

          # Verify architecture
          ARCH=$(file postgresql/bin/postgres)
          echo "Binary architecture: $ARCH"
          if [[ "$ARCH" != *"aarch64"* ]] && [[ "$ARCH" != *"ARM64"* ]] && [[ "$ARCH" != *"arm64"* ]]; then
            echo "::error::Binary is not ARM64 architecture!"
            exit 1
          fi
          echo "✓ Verified ARM64 architecture"

          # Fix RPATH on all ELF binaries to use $ORIGIN-relative paths
          # This ensures binaries find their bundled libraries regardless of install location
          echo "Installing patchelf..."
          sudo apt-get update && sudo apt-get install -y patchelf

          echo "Fixing RPATH on binaries..."
          find postgresql/bin -type f -executable | while read bin; do
            if file "$bin" | grep -q "ELF"; then
              echo "  Fixing RPATH: $bin"
              patchelf --set-rpath '$ORIGIN/../lib' "$bin" 2>/dev/null || true
            fi
          done

          find postgresql/lib -name "*.so*" -type f 2>/dev/null | while read lib; do
            if file "$lib" | grep -q "ELF"; then
              echo "  Fixing RPATH: $lib"
              patchelf --set-rpath '$ORIGIN' "$lib" 2>/dev/null || true
            fi
          done

          # Create tarball (use full VERSION for artifact naming, e.g., 18.1.0)
          tar -czvf "../postgresql-${VERSION}-${PLATFORM}.tar.gz" postgresql

          cd ..
          rm -rf temp downloads

          echo "Download and repackage complete:"
          ls -la .

      # For Linux: use Docker-based source builds (when no download URL available)
      - name: Build for Linux (Docker)
        if: matrix.build_type == 'docker' && steps.check-download.outputs.has_url != 'true'
        id: build-linux
        timeout-minutes: 120
        run: |
          VERSION="${{ github.event.inputs.version }}"
          PLATFORM="${{ matrix.platform }}"

          echo "Building PostgreSQL $VERSION for $PLATFORM"

          ./builds/postgresql/build-local.sh \
            --version "$VERSION" \
            --platform "$PLATFORM" \
            --output ./dist \
            --cleanup

          # Check if artifact was created
          shopt -s nullglob
          FILES=(./dist/postgresql-*.tar.gz)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "::error::No artifact created for $PLATFORM"
            exit 1
          fi
          ls -la ./dist/

      # For Windows: download official EDB binary
      - name: Download for Windows (official EDB binary)
        if: matrix.build_type == 'download'
        id: build-windows
        run: |
          VERSION="${{ github.event.inputs.version }}"
          SOURCE_VERSION="${{ needs.prepare.outputs.source_version }}"

          echo "Downloading PostgreSQL $VERSION for win32-x64 from EDB"

          # Read download URL from sources.json (EDB uses non-predictable file IDs)
          URL=$(jq -r ".versions[\"$VERSION\"][\"win32-x64\"].url" builds/postgresql/sources.json)

          if [ -z "$URL" ] || [ "$URL" = "null" ]; then
            echo "::error::No download URL found in sources.json for version $VERSION win32-x64"
            exit 1
          fi

          echo "Download URL: $URL"

          mkdir -p dist/downloads dist/temp

          # Download with retry
          for i in 1 2 3; do
            if curl -fsSL "$URL" -o "dist/downloads/postgresql-${SOURCE_VERSION}-win32-x64-original.zip"; then
              echo "Download succeeded"
              break
            fi
            echo "Download attempt $i failed, retrying..."
            sleep $((2**i))
          done

          if [ ! -f "dist/downloads/postgresql-${SOURCE_VERSION}-win32-x64-original.zip" ]; then
            echo "::error::Failed to download Windows binary from EDB"
            exit 1
          fi

          # Extract and repackage
          cd dist/temp
          unzip -q ../downloads/postgresql-${SOURCE_VERSION}-win32-x64-original.zip

          # Verify extracted layout and rename for consistency
          echo "Extracted contents:"
          ls -la

          if [ -d "postgresql" ]; then
            echo "Directory 'postgresql' already exists, using as-is"
          elif [ -d "pgsql" ]; then
            # EDB ZIP extracts to 'pgsql' directory - rename to 'postgresql' for consistency
            mv pgsql postgresql
          else
            echo "::error::Unexpected ZIP layout for PostgreSQL ${SOURCE_VERSION} win32-x64"
            echo "Expected 'pgsql' or 'postgresql' directory but found:"
            ls -la
            echo "Contents of dist/temp:"
            find . -maxdepth 2 -type d
            exit 1
          fi

          # Add metadata (use full VERSION for consistency, e.g., 18.1.0)
          cat > postgresql/.hostdb-metadata.json << EOF
          {
            "name": "postgresql",
            "version": "${VERSION}",
            "platform": "win32-x64",
            "source": "official",
            "sourceUrl": "https://www.enterprisedb.com/",
            "rehosted_by": "hostdb",
            "rehosted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          # Create zip with consistent naming (use full VERSION, e.g., 18.1.0)
          zip -rq "../postgresql-${VERSION}-win32-x64.zip" postgresql

          cd ..
          rm -rf temp downloads

          ls -la .

      # For macOS: native build with Homebrew dependencies
      - name: Install macOS build dependencies
        if: matrix.build_type == 'native'
        run: |
          brew install openssl@3 readline libxml2 libxslt icu4c pkg-config

      - name: Build for macOS (native)
        if: matrix.build_type == 'native'
        id: build-macos
        timeout-minutes: 90
        run: |
          # SOURCE_VERSION is 2-part (e.g., 18.1) for downloading PostgreSQL source
          # FULL_VERSION is 3-part (e.g., 18.1.0) for artifact naming
          SOURCE_VERSION="${{ needs.prepare.outputs.source_version }}"
          FULL_VERSION="${{ github.event.inputs.version }}"
          PLATFORM="${{ matrix.platform }}"

          echo "Building PostgreSQL $FULL_VERSION for $PLATFORM (native macOS build)"

          # Get Homebrew prefix (differs between ARM64 and Intel macOS)
          BREW_PREFIX=$(brew --prefix)
          OPENSSL_PREFIX=$(brew --prefix openssl@3)
          ICU_PREFIX=$(brew --prefix icu4c)

          echo "Using OpenSSL at: $OPENSSL_PREFIX"
          echo "Using ICU at: $ICU_PREFIX"

          # Clean up any previous build artifacts
          rm -rf postgresql-source.tar.gz postgresql-${SOURCE_VERSION} install dist

          # Download source (uses 2-part version, e.g., postgresql-18.1.tar.gz)
          curl -fsSL "https://ftp.postgresql.org/pub/source/v${SOURCE_VERSION}/postgresql-${SOURCE_VERSION}.tar.gz" \
            -o postgresql-source.tar.gz
          tar -xzf postgresql-source.tar.gz

          cd postgresql-${SOURCE_VERSION}

          # Fix for Xcode 16+ SDK/toolchain mismatch issues
          # Force latest Xcode as the active developer directory
          XCODE_PATH=$(ls -d /Applications/Xcode*.app 2>/dev/null | sort -V | tail -1)
          echo "Using Xcode: $XCODE_PATH"
          sudo xcode-select -s "$XCODE_PATH/Contents/Developer"

          # Get SDK and toolchain paths
          export SDKROOT=$(xcrun --sdk macosx --show-sdk-path)
          XCODE_TOOLCHAIN=$(xcode-select -p)/Toolchains/XcodeDefault.xctoolchain

          echo "Using Xcode SDK (SDKROOT): $SDKROOT"
          echo "Using Xcode Toolchain: $XCODE_TOOLCHAIN"

          # Set compiler environment variables to force correct SDK
          export CC="$XCODE_TOOLCHAIN/usr/bin/clang"
          export CXX="$XCODE_TOOLCHAIN/usr/bin/clang++"
          export CFLAGS="--sysroot=$SDKROOT -I${OPENSSL_PREFIX}/include -I${ICU_PREFIX}/include"
          export CPPFLAGS="$CFLAGS"
          export LDFLAGS="--sysroot=$SDKROOT -L${OPENSSL_PREFIX}/lib -L${ICU_PREFIX}/lib"
          export PKG_CONFIG_PATH="${OPENSSL_PREFIX}/lib/pkgconfig:${ICU_PREFIX}/lib/pkgconfig"

          # Verify clang uses correct SDK
          echo "Clang SDK check:"
          $CC --version
          $CC -v -E -x c /dev/null 2>&1 | grep "selected sysroot" || true

          # Configure PostgreSQL
          ./configure \
            --prefix="$GITHUB_WORKSPACE/install/postgresql" \
            --with-openssl \
            --with-readline \
            --with-libxml \
            --with-libxslt \
            --with-icu \
            --without-systemd

          # Build
          make -j$(sysctl -n hw.ncpu)

          # Install
          make install

          # Build and install contrib modules
          cd contrib
          make -j$(sysctl -n hw.ncpu)
          make install
          cd ..

          # Add metadata (use full 3-part version for consistency)
          cd "$GITHUB_WORKSPACE/install"
          cat > postgresql/.hostdb-metadata.json << EOF
          {
            "name": "postgresql",
            "version": "${FULL_VERSION}",
            "platform": "${PLATFORM}",
            "source": "source-build",
            "sourceUrl": "https://ftp.postgresql.org/",
            "rehosted_by": "hostdb",
            "rehosted_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF

          # Verify key binaries exist
          test -f postgresql/bin/postgres || { echo "::error::postgres binary not found"; exit 1; }
          test -f postgresql/bin/psql || { echo "::error::psql binary not found"; exit 1; }
          test -f postgresql/lib/pg_stat_statements.so || echo "::warning::pg_stat_statements.so not found"

          # Make binaries relocatable by fixing hardcoded paths
          # This ensures binaries work regardless of where they're installed
          echo "Making binaries relocatable..."

          # Enable nullglob so unmatched patterns expand to nothing
          shopt -s nullglob

          # Function to get all non-system dylib dependencies
          get_external_deps() {
            otool -L "$1" 2>/dev/null | tail -n +2 | awk '{print $1}' | \
              grep -v '^/usr/lib/' | grep -v '^/System/' | grep -v '@executable_path' | grep -v '@rpath' | grep -v '@loader_path' || true
          }

          # Copy required Homebrew dylibs into our lib directory
          echo "Bundling external dependencies..."
          DEPS_TO_PROCESS=()
          PROCESSED_DEPS=()

          # Collect initial dependencies from all binaries and libraries
          for binary in postgresql/bin/*; do
            if [[ -f "$binary" && -x "$binary" ]]; then
              while IFS= read -r dep; do
                [[ -n "$dep" ]] && DEPS_TO_PROCESS+=("$dep")
              done < <(get_external_deps "$binary")
            fi
          done

          for lib in postgresql/lib/*.dylib postgresql/lib/*.so; do
            if [[ -f "$lib" ]]; then
              while IFS= read -r dep; do
                [[ -n "$dep" ]] && DEPS_TO_PROCESS+=("$dep")
              done < <(get_external_deps "$lib")
            fi
          done

          # Process dependencies (including transitive ones)
          while [[ ${#DEPS_TO_PROCESS[@]} -gt 0 ]]; do
            dep="${DEPS_TO_PROCESS[0]}"
            DEPS_TO_PROCESS=("${DEPS_TO_PROCESS[@]:1}")

            # Skip if already processed
            for processed in "${PROCESSED_DEPS[@]:-}"; do
              [[ "$dep" == "$processed" ]] && continue 2
            done
            PROCESSED_DEPS+=("$dep")

            # Skip if not a file
            [[ ! -f "$dep" ]] && continue

            libname=$(basename "$dep")
            target="postgresql/lib/$libname"

            # Skip if already exists
            [[ -f "$target" ]] && continue

            echo "  Bundling: $libname"
            cp "$dep" "$target"
            chmod 755 "$target"

            # Check for transitive dependencies
            while IFS= read -r transitive; do
              [[ -n "$transitive" ]] && DEPS_TO_PROCESS+=("$transitive")
            done < <(get_external_deps "$target")
          done

          # Fix the bundled dylibs - set their install names and fix internal references
          echo "Fixing bundled dylib install names..."
          for dylib in postgresql/lib/*.dylib; do
            if [[ -f "$dylib" ]]; then
              libname=$(basename "$dylib")

              # Set the library's own install name to use @rpath
              install_name_tool -id "@rpath/$libname" "$dylib" 2>/dev/null || true

              # Fix references to other libraries
              while IFS= read -r dep; do
                if [[ -n "$dep" ]]; then
                  depname=$(basename "$dep")
                  install_name_tool -change "$dep" "@rpath/$depname" "$dylib" 2>/dev/null || true
                fi
              done < <(get_external_deps "$dylib")
            fi
          done

          # Fix binaries to use @executable_path/../lib for bundled libraries
          echo "Fixing binary library paths..."
          for binary in postgresql/bin/*; do
            if [[ -f "$binary" && -x "$binary" ]]; then
              # Add rpath for finding libraries relative to executable
              install_name_tool -add_rpath "@executable_path/../lib" "$binary" 2>/dev/null || true

              # Fix references to external libraries
              while IFS= read -r dep; do
                if [[ -n "$dep" ]]; then
                  depname=$(basename "$dep")
                  install_name_tool -change "$dep" "@executable_path/../lib/$depname" "$binary" 2>/dev/null || true
                fi
              done < <(otool -L "$binary" 2>/dev/null | tail -n +2 | awk '{print $1}' | \
                grep -v '^/usr/lib/' | grep -v '^/System/' | grep -v '@executable_path' | grep -v '@rpath' || true)
            fi
          done

          # Fix .so files (PostgreSQL extensions) the same way
          echo "Fixing extension library paths..."
          for lib in postgresql/lib/*.so; do
            if [[ -f "$lib" ]]; then
              install_name_tool -add_rpath "@loader_path" "$lib" 2>/dev/null || true

              while IFS= read -r dep; do
                if [[ -n "$dep" ]]; then
                  depname=$(basename "$dep")
                  install_name_tool -change "$dep" "@rpath/$depname" "$lib" 2>/dev/null || true
                fi
              done < <(otool -L "$lib" 2>/dev/null | tail -n +2 | awk '{print $1}' | \
                grep -v '^/usr/lib/' | grep -v '^/System/' | grep -v '@executable_path' | grep -v '@rpath' || true)
            fi
          done

          # Verify no hardcoded paths remain
          echo "Verifying relocatable binaries..."
          FAILED=0
          for binary in postgresql/bin/postgres postgresql/bin/psql postgresql/bin/initdb; do
            if [[ -f "$binary" ]]; then
              REMAINING=$(otool -L "$binary" 2>/dev/null | grep -E '/Users/|/opt/homebrew/' || true)
              if [[ -n "$REMAINING" ]]; then
                echo "::warning::Hardcoded paths remain in $(basename $binary):"
                echo "$REMAINING"
                FAILED=1
              fi
            fi
          done

          if [[ $FAILED -eq 0 ]]; then
            echo "✓ All binaries are relocatable"
          fi

          # Create tarball (use full 3-part version for artifact naming)
          mkdir -p "$GITHUB_WORKSPACE/dist"
          tar -czvf "$GITHUB_WORKSPACE/dist/postgresql-${FULL_VERSION}-${PLATFORM}.tar.gz" postgresql

          echo "Build complete:"
          ls -la "$GITHUB_WORKSPACE/dist/"

      - name: Generate checksum
        run: |
          cd dist
          shopt -s nullglob
          for f in *.tar.gz *.zip; do
            if [ -f "$f" ]; then
              if command -v sha256sum &> /dev/null; then
                sha256sum "$f" >> checksums.txt
              else
                # macOS uses shasum
                shasum -a 256 "$f" >> checksums.txt
              fi
            fi
          done
          cat checksums.txt

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: postgresql-${{ github.event.inputs.version }}-${{ matrix.platform }}
          path: |
            dist/*.tar.gz
            dist/*.zip
            dist/checksums.txt
          retention-days: 1

  # Collect all artifacts and create release
  release:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./artifacts
          pattern: postgresql-${{ github.event.inputs.version }}-*

      - name: Prepare release assets
        run: |
          mkdir -p ./release-assets

          # Move all artifacts to release-assets, flattening the directory structure
          find ./artifacts -type f \( -name "*.tar.gz" -o -name "*.zip" \) -exec mv {} ./release-assets/ \;

          # Combine all checksums
          find ./artifacts -name "checksums.txt" -exec cat {} \; > ./release-assets/checksums.txt

          echo "Release assets:"
          ls -la ./release-assets/

          # Verify we have at least one artifact
          shopt -s nullglob
          FILES=(./release-assets/*.tar.gz ./release-assets/*.zip)
          if [ ${#FILES[@]} -eq 0 ]; then
            echo "ERROR: No artifacts were created for any platform"
            exit 1
          fi

          echo ""
          echo "Checksums:"
          cat ./release-assets/checksums.txt

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: postgresql-${{ github.event.inputs.version }}
          name: PostgreSQL ${{ github.event.inputs.version }}
          body: |
            ## PostgreSQL ${{ github.event.inputs.version }}

            PostgreSQL binaries built from source for hostdb.

            ### Available Platforms
            | Platform | Source |
            |----------|--------|
            | `linux-x64` | Built from source (Docker) |
            | `linux-arm64` | Built from source (Docker/QEMU) |
            | `darwin-x64` | Built from source (native macOS) |
            | `darwin-arm64` | Built from source (native macOS) |
            | `win32-x64` | Official EDB binary |

            ### Features
            - All contrib modules included (pg_stat_statements, etc.)
            - Built with SSL, readline, XML, XSLT, and ICU support

            ### Usage
            ```bash
            # Download URL pattern
            https://github.com/${{ github.repository }}/releases/download/postgresql-${{ github.event.inputs.version }}/postgresql-${{ github.event.inputs.version }}-<platform>.tar.gz
            ```

            ### Checksums
            See `checksums.txt` for SHA256 checksums.

            ### Sources
            - **Source Builds**: [ftp.postgresql.org](https://ftp.postgresql.org/pub/source/)
            - **Windows Binary**: [EnterpriseDB](https://www.enterprisedb.com/)
          files: |
            release-assets/*.tar.gz
            release-assets/*.zip
            release-assets/checksums.txt
          fail_on_unmatched_files: false

  # Update the releases manifest
  update-manifest:
    needs: release
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: main

      - name: Setup pnpm
        uses: pnpm/action-setup@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Update releases.json
        run: |
          pnpm tsx scripts/update-releases.ts \
            --database postgresql \
            --version "${{ github.event.inputs.version }}" \
            --tag "postgresql-${{ github.event.inputs.version }}"

      - name: Commit and push
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add releases.json
          git diff --staged --quiet && echo "No changes to commit" && exit 0

          git commit -m "chore: update releases.json for postgresql-${{ github.event.inputs.version }}"

          # Retry push with rebase if remote has changed
          for i in 1 2 3; do
            if git push; then
              echo "Push succeeded"
              exit 0
            fi
            echo "Push failed, attempting rebase (attempt $i/3)..."
            git fetch origin main
            if ! git rebase origin/main; then
              echo "ERROR: Rebase failed due to conflicts. Manual intervention required."
              git rebase --abort
              exit 1
            fi
            sleep $((2**i))
          done
          echo "ERROR: Push failed after 3 attempts"
          exit 1

  # Trigger sync to ensure releases.json is fully up to date
  trigger-sync:
    needs: update-manifest
    runs-on: ubuntu-latest
    steps:
      - name: Trigger sync-releases workflow
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh workflow run sync-releases.yml --repo ${{ github.repository }}
          echo "Triggered sync-releases workflow"
